package jobs

import java.io._
import java.nio.file.Files
import java.util.jar.JarOutputStream
import java.util.zip.{ZipInputStream, ZipEntry}

import play.api.libs.concurrent.Akka
import play.api.{Play, Mode, DefaultApplication}
import play.api.libs.json._
import play.api.libs.json.Reads._
import play.api.libs.functional.syntax._
import utils.{StandaloneWS, PackageInfo, Bower}

import scala.annotation.tailrec
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.{Await, Future}
import scala.concurrent.duration._
import scala.util.{Failure, Success}

object PublishBowerWebJar extends App {

  // Don't let the Play Akka Scheduler block exiting
  System.setProperty("play.akka.daemonic", "on")

  val name = "bootstrap"
  val version = "1.0.0"

  // converts JsResult to Future
  def packageInfo(json: JsValue): Future[PackageInfo] = Json.fromJson[PackageInfo](json).fold(
    errors => Future.failed(new Exception(errors.toString())),
    Future.successful
  )

  def createWebJar(zip: ZipInputStream, pom: String, name: String, version: String): JarOutputStream = {

    def createDir(dir: String, jar: JarOutputStream): Unit = {
      val ze = new ZipEntry(dir)
      jar.putNextEntry(ze)
      jar.closeEntry()
    }

    def createFileEntry(path: String, jar: JarOutputStream, contents: String): Unit = {
      val ze = new ZipEntry(path)
      jar.putNextEntry(ze)
      jar.write(contents.getBytes)
      jar.closeEntry()
    }

    val jar = new JarOutputStream(new FileOutputStream("/tmp/foo.jar")) //new ByteArrayOutputStream())

    createDir(s"META-INF/", jar)
    createDir(s"META-INF/maven/", jar)
    createDir(s"META-INF/maven/org.webjars.bower/", jar)
    createDir(s"META-INF/maven/org.webjars.bower/$name/", jar)

    createFileEntry(s"META-INF/maven/org.webjars.bower/$name/pom.xml", jar, pom)

    val properties = s"""
         |#Generated by WebJar Bower Sync
         |version=$version
         |groupId=org.webjars.bower
         |artifactId=$name
       """.stripMargin

    createFileEntry(s"META-INF/maven/org.webjars.bower/$name/pom.properties", jar, properties)

    val webJarPrefix = s"META-INF/resources/webjars/$name/$version/"

    createDir(s"META-INF/resources/", jar)
    createDir(s"META-INF/resources/webjars/", jar)
    createDir(s"META-INF/resources/webjars/$name/", jar)
    createDir(webJarPrefix, jar)

    // copy zip to jar, excluding .bower.json
    val zipEntryTraverable = new ZipEntryTraversableClass(zip)

    zipEntryTraverable.foreach { ze =>
      if (ze.getName != ".bower.json") {
        val path = webJarPrefix + ze.getName
        val nze = new ZipEntry(path)
        jar.putNextEntry(nze)
        zipEntryTraverable.writeCurrentEntryTo(jar)
      }
    }

    zip.close()
    jar.close()

    jar
  }

  StandaloneWS.withWs { implicit ws =>
    val bower = Bower(global, ws)

    val webJarFuture = for {
      packageInfo <- bower.info(name, version)
      pom = views.xml.pom(packageInfo).toString()
      zip <- bower.zip(name, version)
      jar = createWebJar(zip, pom, name, version)
    } yield {
      (pom, jar)
    }

    webJarFuture

  } onComplete {
    case Success(s) =>
      println("Done!")
    case Failure(f) =>
      println("Error: ", f)
  }

  // create package & version on BinTray

  // upload pom.xml and foo.jar to BinTray

  // sign on BinTray

  // release to Maven Central

}

// from: http://harrah.github.io/browse/samples/compiler/scala/tools/nsc/io/ZipArchive.scala.html
class ZipEntryTraversableClass(zis: ZipInputStream) extends Traversable[ZipEntry] {

  def foreach[U](f: ZipEntry => U) {
    @tailrec
    def loop(x: ZipEntry): Unit = if (x != null) {
      f(x)
      zis.closeEntry()
      loop(zis.getNextEntry)
    }
    loop(zis.getNextEntry)
  }

  def writeCurrentEntryTo(os: OutputStream) {
    val bytes = new Array[Byte](1024)
    Iterator
      .continually(zis.read(bytes))
      .takeWhile(_ != -1)
      .foreach(read => os.write(bytes, 0, read))
    zis.closeEntry()
  }
}